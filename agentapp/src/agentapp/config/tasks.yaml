decompose_task:
  description: >
    Analyze the incoming feature request: "{user_input}".
    Decompose this request into specific, actionable instructions for each specialized agent.
    You must create clear, separate instructions for:
    1. Frontend Agent - specific UI/UX tasks, components to build, user interactions, and folder structure
    2. Backend Agent - specific API endpoints, data models, security requirements, business logic, and folder structure
    3. QA Agent - specific test requirements and validation criteria
    
    Be extremely specific and detailed in your decomposition so each agent knows exactly what to build.
    Specify the folder structure that should be created (e.g., frontend/components/, backend/routes/, etc.).
  expected_output: >
    A structured decomposition in the following format:
    
    ## Frontend Task
    [Detailed instructions for frontend development including:
    - Specific components to build
    - User flows and UI requirements
    - Folder structure (e.g., components/, pages/, styles/)
    - File organization and naming conventions]
    
    ## Backend Task  
    [Detailed instructions for backend development including:
    - API endpoints with exact paths and methods
    - Data models and database schemas
    - Security requirements (authentication, validation, etc.)
    - Business logic
    - Folder structure (e.g., routes/, models/, services/)
    - Dependencies and requirements]
    
    ## QA Requirements
    [Specific test cases and validation criteria including:
    - Unit tests
    - Integration tests
    - End-to-end test scenarios
    - Expected behaviors and edge cases]
    
    Each section must be detailed enough for the respective agent to implement without ambiguity.
  agent: orchestrator_agent
  allow_delegation: True
  output_file: outputs/decomposition_output.md

# Frontend task, delegated by the orchestrator
frontend_coding_task:
  description: >
    Review the decomposition provided by the orchestrator in the context.
    Extract the "## Frontend Task" section from the orchestrator's decomposition output.
    
    Your task is to implement EXACTLY what the orchestrator specified in the Frontend Task section.
    Do NOT use the original user_input directly - only use the specific frontend instructions from the decomposition.
    
    CRITICAL INSTRUCTIONS FOR FILE CREATION:
    You have access to a 'create_file' tool that you MUST use to create actual code files.
    
    1. You MUST use the create_file tool to create a folder structure in outputs/frontend/ directory
    2. For each file you need to create, use the create_file tool with:
       - file_path: relative path from outputs/ (e.g., 'frontend/components/App.jsx')
       - content: the complete file content
    3. Create the exact folder structure specified in the decomposition (e.g., frontend/components/, frontend/pages/, frontend/styles/, etc.)
    4. Create ACTUAL code files (.js, .jsx, .ts, .tsx, .css, .html) with real, working code
    5. DO NOT just write code descriptions in markdown - you MUST use the create_file tool to create actual executable files
    6. Each file must contain complete, functional code that can be directly used
    7. Call the create_file tool for EVERY file that needs to be created
    8. Ensure the component is wired up to submit data to the API path specified in the orchestrator's decomposition
    
    If the decomposition mentions specific API endpoints or backend requirements, coordinate with those specifications.
    
    Example folder structure you should create:
    outputs/frontend/
      components/
        ComponentName.jsx
        ComponentName.css
      pages/
        PageName.jsx
      styles/
        global.css
      README.md
    
    Create all files with proper code, not just descriptions.
  expected_output: >
    A summary in outputs/frontend_output.md describing:
    1. The folder structure created in outputs/frontend/
    2. List of all files created with their paths
    3. Brief description of what each file does
    4. How to run/use the frontend code
    
    NOTE: The actual code files should be created in outputs/frontend/ directory with proper folder structure.
    The output_file (frontend_output.md) is just a summary - the actual implementation must be in outputs/frontend/.
  agent: frontend_agent
  context:
    - decompose_task
  async_execution: True # Can run in parallel with the backend task
  output_file: outputs/frontend_output.md
  allow_delegation: False

# Backend task, delegated by the orchestrator
backend_coding_task:
  description: >
    Review the decomposition provided by the orchestrator in the context.
    Extract the "## Backend Task" section from the orchestrator's decomposition output.
    
    Your task is to implement EXACTLY what the orchestrator specified in the Backend Task section.
    Do NOT use the original user_input directly - only use the specific backend instructions from the decomposition.
    
    CRITICAL INSTRUCTIONS FOR FILE CREATION:
    You have access to a 'create_file' tool that you MUST use to create actual code files.
    
    1. You MUST use the create_file tool to create a folder structure in outputs/backend/ directory
    2. For each file you need to create, use the create_file tool with:
       - file_path: relative path from outputs/ (e.g., 'backend/routes/api.py')
       - content: the complete file content
    3. Create the exact folder structure specified in the decomposition (e.g., backend/routes/, backend/models/, backend/services/, etc.)
    4. Create ACTUAL code files (.py, requirements.txt, etc.) with real, working code
    5. DO NOT just write code descriptions in markdown - you MUST use the create_file tool to create actual executable files
    6. Each file must contain complete, functional code that can be directly run
    7. Call the create_file tool for EVERY file that needs to be created
    8. Implement the exact API endpoints, data models, security requirements (like password hashing),
       input validation, and business logic as specified by the orchestrator
    9. The endpoints MUST be functional and ready to accept the payload format specified in the decomposition
    
    Ensure your implementation matches the API contract that the frontend agent will be using.
    
    Example folder structure you should create:
    outputs/backend/
      routes/
        api.py
      models/
        user.py
      services/
        auth.py
      requirements.txt
      README.md
      app.py (or main.py)
    
    Create all files with proper code, not just descriptions.
  expected_output: >
    A summary in outputs/backend_output.md describing:
    1. The folder structure created in outputs/backend/
    2. List of all files created with their paths
    3. Brief description of what each file does
    4. API endpoints with paths, methods, request/response formats
    5. How to run/install the backend code
    6. Dependencies and requirements
    
    NOTE: The actual code files should be created in outputs/backend/ directory with proper folder structure.
    The output_file (backend_output.md) is just a summary - the actual implementation must be in outputs/backend/.
  agent: backend_agent
  context:
    - decompose_task
  async_execution: True # Can run in parallel with the frontend task
  output_file: outputs/backend_output.md
  allow_delegation: False

# Final QA task, always runs last and depends on both coding tasks
final_qa_validation_task:
  description: >
    Review the decomposition provided by the orchestrator to understand the QA requirements.
    Extract the "## QA Requirements" section from the orchestrator's decomposition output.
    
    Analyze the code outputs from the 'frontend_coding_task' and 'backend_coding_task'.
    Your goal is to verify that:
    1. The orchestrator's specific QA requirements (from the decomposition) have been met
    2. The original user requirement ("{user_input}") has been fully satisfied
    3. The frontend and backend implementations are properly integrated
    
    Use the QA requirements from the decomposition as your primary test criteria.
    If the code fails, identify the failure point (Frontend logic error, Backend bug, or integration issue)
    and output a structured failure report.
  expected_output: >
    A final verdict: 'PASS' or 'FAIL' followed by a detailed, technical explanation.
    Reference both the orchestrator's QA requirements and the original user requirement in your assessment.
    Example PASS: "PASS: The registration flow is complete. Password hashed correctly and UI state management works."
    Example FAIL: "FAIL: The frontend button calls '/submit', but the backend endpoint is '/save'. This is a dependency failure."
  agent: qa_tester_agent
  context:
    - frontend_coding_task
    - backend_coding_task
    - decompose_task
  output_file: outputs/qa_validation_output.md
  allow_delegation: False
